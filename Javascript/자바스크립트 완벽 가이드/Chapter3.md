## 타입, 값, 변수
 - 자바스크립트의 타입은 크게 **원시타입(primitive type)** 과 **객체타입(object type)** 으로 나뉘고,
 - 원시 타입으로는 숫자, 텍스트의 나열(문자여라, string), 불리언 진리 값(불리언, boolean이라고 함)이 있다.
 - **nul** l과 **undefined** 는 원시값이긴 하지만, 숫자도 아니고 문자열이나 불리언도 아니다. 자바스트립트에서 null과 undefined는 자기 자신만을 값으로 갖는 독립적인 타입에 속한다.
 - 숫자와 문자열, 불리언, null, undefined **외의 값은 객체다.**
 - **객체(즉, object 타입의 맴버)** 는 이름과 값을 프로퍼티의 집합이다.(여기서 값은 숫자나 문자열 같은 기본 데이터 타입 값이 될 수도 있고 객체가 될 수도있다.)
 - 자바스크립트 객체는 숫서가 없는 값들의 집합이다.
   - 배열(Array)이라고 알려진 특별한 종류의 객체도 있다.
   - 함수라고 부르는 특별한 객채도 있다 -> 함수는 실행 코드를 가지고 있는 객체.

## 숫자
 - 다른 프로그래밍 언어들과는 다르게 자바스크립트는 정수 값과 실수 값을 구분하지 않는다.
 - 모든 숫자를 실수로 표현한다.
 - 프로그램 안에서 있는 그대로 등장하는 숫자를 숫자 리터널(numeric literal)이라고 한다.

## 산술 연산
 - 오버플로
   - 산술 연산의 결과가 표현할 수 있는 가장 큰 수보다 더 크다면 (오버플로), 자바스크립트는 Infinity라고 표현
   - 비슷하게 표현 가능한 가장 자은 음수 값보다 더 작은 값은 음의 무한대가 되면 자바스트립트는 -Infinity로 출력
 - 언더플로
   - 산술의 연산 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울 때 발행한다. 이런 경우는 0을 돌려 준다.
 - **NaN**
   - 0을 0으로 나누는 것은 정의되지 않은 값을 갖고, 그 결과로 숫자가 아닌 특수한 값을 가진다.
   - 이러한 값을 NaN으로 출력한다.
   - 또 무한대를 무한대로 나누는 경우, 음수값에 루트를 씌우는 경우, 수자가 아닌 피연산자로 산술 연살을 시도하는 경우에도 발행한다.
   - NaN의 톡특한 기능
     - NaN은 그 자신뿐만 아니라 다른 값과 같은지 비교할 수 없다.
     - 다시 말해 x가 NaN인지 판단하기 위해 x == NaN 문을 작성 할 수 없다.
     - 대신 x != x 라고 작성해야 한다.
     - **isNaN()** 함수는 이러한 경우에 유용하게 사용할 수 있다.
       - 인자가 NaN이거나, 문자열이나 객체처럼 숫자가 아니라면 참을 반환한다.
     - **isFinite()** 는 인자가 NaN, Infinity, -Infinity 이외의 숫자라면 참을 반환한다.
## 텍스트(3.2)
 - 문자열(string)은 16비트 값들이 연속적으로 나열된 변경이 불가능한 값으로, 각 문자는 유니코드 문자를 표현된다.
## 문자열 리터럴(3.2.1)
 - <pre><code>"one\          //세 줄로 표현된 한 줄 문자열.
    long\
    line"
   </pre></code>
 - 아포스트로피(')
## 문자열 리터럴 내의 이스케이프 문자열(3.2.2)
 - 자바스트립트 이스케이프 시퀀스들
    시퀀스  | 표현하는 문자
    ---------- | ----------
    \0 | 널 문자 (\u0000)
    \b | 역스페이즈 (\u0008)
    \t | 수평탭 (\u0009)
    \n | 줄바꿈 문자 (\u000A)
    \v | 수직 탭 (\u000B)
    \f | 폼 피드 (\u000C)
    \r | 캐리지 리턴 (\u000D)
    \" | 큰 따움표 (\u0022)
    \' | 작은 따움표 (\u0027)
    \\\ | 역슬래시 (\u005C)
    \x | 두 개의 16진수 숫자 XX에 의해 지정되는 Latin-1 문자
    \u | 네 개의 16진수 숫자 XXXX에 의해 지정되는 유니코드 문자

## 문자열 다루기(3.2.3)
 - 자바스크립트에서 문자열은 변경 되지 않는다.
 - replace()와 toUpperCase() 같은 메서드는 기존 문자열을 변경하지 않고 새 문자열을 반환한다.
 - 즉, 문자열 관련 메서드는 호출 시에 기존 문자열을 수정하지 않는다.

## 패턴 매칭(3.2.4)
 - 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 정의 한다.
 - 이 패턴은 정규 표현식이라 한다.
 - Date 객채처럼 RegExp는 유용한 API를 가지고 있는 툭별한 종류의 객체다

## 불리언 값(3.3.)
 - 불리언(Boolean)값은 참/거짓, on/off, yes/no를 표현한다.
 - 다음은 모두 불리언 false 값으로 변한다.
 `undefined`
 `null`
 `0`
 `-0`
 `NaN`
 `""` //빈 문자열
 - 객체(와 배열)를 포함하는 다른 모든 값은 불리언 값 true로 변환

## null과 undefined
- null
  - null은 보통 아무 값도 갖지 않음을 가리킬 때 사용 된다.
  - typeof 연산자를 null에 사용하면 문자열 'object'를 반환한다.
  - null은 '객체가 없음'을 뜻하는 특수한 객체 값으로 생각할 수 있다.
- undefined
  - 자바스크립트에는 값이 없을을 나타내는 또 다른 값.
  - undefined는 null보다, 심한 부재 상태를 나타낸다.
  - 초기화되어 있지 않은 변수나, 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 얻는 값이다.
  - 반환값이 없는 함수의 반환값
  - undefined는 미리 선언된 전역 번수이며, 정의되지 않은 값으로 초기화된다.
  - typeof 연잔자를 undefined 값에 사용한다면 "undefined"가 반환된다.
- 시스템 수준에서 예기치 않은 상황에 발생한, 오류성 값 부재를 표현 할 때는 주로 undefined를 사용한다.
- 일번적인 프로그램 수준에서 일반적으로, 또는 예상 가능한 값 부재 상황을 표현하고 싶을 때는 null을 사용한다.
- 변수나 프로퍼티에 할당할 필요가 있거나 함수에 인자로 전달할 필요가 있다면 null을 사용하는게 적절하다.

## 전역객체(3.5)
- 전역 객치(global object)는 매우 중요한 용도로 사용되는 일반적인 자바스트립트 객체다.
- 전역 객체의 프로퍼티는 자바 스트립트 프로그램 전역에서 사용할 수 있게 정의 된 심벌이다.

## 래퍼(warpper) 객체
 ```javascript
 var s = 'test'  //이 문자열을 사용한다.
 s.len = 4;      //문자열 프로퍼티에 값을 할당한다.
 var t = s.len;  //프로퍼티를 참조하다.
 ```
- 우리가 문자열 프러퍼티에 접근하려고 할때(가령 length 같은) 자바스크립트는  new String를 호출하는 것처럼 문자열을 각 객체로 변환 한다. 이 객체를 래퍼 객체라고 한다.
- 래퍼객체는 프로퍼티를 참조 할때 생성되며 피로퍼티를 참조가 끝나면 사라 진다.
- t값은 undefined이다.
- 2행은 생성된 임시 String 객체의 len 프로퍼티데 4를 할당한다. **그리고 바로 삭제 된다.**
- 3행은 기존 문자열 값과 같은 값을 가진 새로운 String 객체를 생성하고 len 프로퍼티를 읽으려 한다.
- 이 프러퍼티는 존재하지 않아서 undefined로 평가 된다.
- 값을 할당하는 것은 임시 객체에서 수행되며, 지속되지 않는다.
- 문자열, 숫자, 불리언의 프로퍼티에 접근하려고 할 때 생성되는 임시 객체는 **래퍼(wrapper)** 객체로 알려져 있다.

## 변경 불가능한 원시 타입 값과 변경 가능 객체 참조(3.7)
- 원시타입(undefined, null, 불리언, 숫자, 문자열)
  - 값은 수정할 수 없다.
  - 숫자와 불리언의 경우는 매우 명확한다.
  - 문자열을 수정하는 모든 문저열 메서드는 새로운 문자열을 반환한다.
    ```javascript
    var s = 'hello'   // 'hellop' 문자열을 사용한다.
    s.toUpperCase();  // 'HELLO'을 반환한다, 하지만 s는 변경되지 않는다.
    s                 // => 'hello'; 원래의 문자열은 바뀌지 않았다.
    ```
- 객체(배열과 함수를 포함한)
  - 자신의 값을 변경할 수 있다.
    ```javascript
    var o = { x: 1};    // 객체를 선언한다.
    o.x = 2;            // 프로퍼티의 값을 변경함으로써 객체를 변경한다.
    o.y = 3;            // 다시 새로운 프로퍼티를 추가하는 것으로 객체를 변경한다.
    var a = [1,2,3]     // 배열은 타입이 고정되어 있지 않다.
    a[0] = 0;           // 하나의 배열 원소 값을 바꾼다.
    a[3] = 4;           // 새로운 하나의 배열 원소를 추가한다.
    ```
  - 두 객체가 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다.
  - 두 배열은 같은 순서로 같은 원소를 갖고 있어도 같지 않다.
    ```javascript
    var 0 = {x: 1}, p = {x: 1};   //같은 프로퍼티를 가지고 있는 두 객체
    o === p                       // => false; 같지 않은 다른 두 객체
    var a =[], b = [];            // 두 개의 빈 배열 a와 b를 선언
    a === b                       // => false;
    ```
  - 객체는 참조 타입(reference type)
    ```javascript
    var a = [];   // 변수 a는 빈 배열을 참조한다.
    var b = a;    // 변수 b는 a와 같은 배열을 참조한다.
    b[0] = 1;     // 변수 b가 참조하는 배열을 변경한다.
    a[0]          // => 1: 변수 a를 통해서도 바뀐 점을 볼 수 있다.
    a === b       // => true; 변수 a와 b는 한 객체를 참조하기 때문에 같다.
    ```
## 타입 변환(3.8)
 - 자바스크립트는 타입에 대해 매우 유연하다.
   ```javascript
   10 + ' objects'      // => "10 objects". 숫자 10은 문자열로 변환된다.
   '7' * '4'            // => 28: 두 문자열은 숫자로 변환한다.
   var n = 1 - 'x';     // => NaN: 문자열 "x"는 숫자로 변환할 수 없다.
   n + ' objects';      // => "NaN objects": NaN은 문자열 "NaN"으로 변환된다.
   ```
 - 자바스크립트 타입 변환

   | 값  | String | Number | Boolean | Object
   |:-------- | -------- | -------- | -------- | -------- |
   | undefined | "undefined" | NaN | false | TypeError 예외 발생 |
   | null | null | 0 | false| Type Error 예외 발생 |
   | true | "true" | 1 || new Boolean(true)|
   | false | "false" | 0 || new Boolean(false)|
   | ""(빈 문자열) || 0 | false | new String("")|
   | "1.2"(숫자 문자열) || 1.2 | true | new String("1.2")|
   | "one"(문자열) || NaN| true| new String("one")|
   | 0 | "0" || false | new Number(0) |
   | -0 | "0" || false | new Number(-0) |
   | NaN | "NaN" || false | new Number(NaN) |
   | Infinity | "Infinity" || true | new Number(Infinity) |
   | -Infinity | "-Infinity" || true | new Number(-Infinity) |
   | 1(0이 아닌 유한한 값) | "1" || true | new Number(1) |
   | {}(객체) | (3.8.3참고) | (3.8.3참고) | true ||
   | [ ] (배열) | "" | 0 | true ||
   | [9] (배열의 원소가 1개이고, 값이 숫자일 경우)| "9" | 9 | true ||
   | ['a'] (배열) | (join() 메소드를 사용할 것) | NaN| true ||
   | function(){} (함수) | (3.8.3 참고) | NaN | true ||

## 변환과 동치(3.8.1)
 - 동치 연산자 ==도 유연하게 동작한다.
   ```javascript
   numm == undefined   // true
   "0" == 0            // 비교하기 전에 숫자로 변환한다.
   0 == false          // 불리언은 비교하기 전에 숫자로 변환한다.
   "0" == false        // 두 피연산자는 비교하기 전에 숫자로 변환한다.
   ```
## 명시적 변화(3.8.2)
- 자바스크립트는 많은 형 변환을 자동으로 수행하지만, 명지적 변환이 필요한 때가 있다.
- Boolean(), Number(), String(), Object()
  ```javascript
  Number("3")         // => 3
  String("false")     // => "false" false.toString()도 마찬가지다.
  Boolean([ ])        // => true
  Object(3)           // => new Number(3)

  x + ""              // String(x)와 같다
  +x                  // Number(x)와 같다. 결과는 x-0이다.
  !!x                 // Boolean(x)과 같다. 두 개의 !를 주목하라
  ```
## 객체에서 원시 타입의 변환(3.8.3)
- 모든 객체(배열과 함수를 포함한)는 true로 변환된다.
- new Boolean(false)는 원시 타입이 아니라 객체이므로 true로 변환 된다.
- 모든 객체는 두 개의 타입 변환 메서드를 상속한다.
  - `toString()`: 객체를 문자열로 표현하여 반환한다.
    ```javascript
    ({x: 1, y: 2}).toString()           // => "[object object]"
    [1,2,3].toString()                  // => "1,2,3"
    (function(x) { f(x); }).toString()  // => "function(x) {\n f(x); \n}"
    /\d+\g.toString()                   // => "/\\d+/g"
    new Date(2010,0,1).toString()       // => "Fri Jan 01 2010 00:00:00 GMT-0800 (PST)"
    ```
  - `valueOf()`: 하는 일은 잘 정의되어 있지 않다.
  월래 이 함수는 객체를 잘 표현하는 원시 타입을 반환해야 한다. 그런데 객체는 결합된 값(compound value)이고 대부분의 객체는 원시타입 값으로 표현할 수 없기 때문에, **기본적으로 valueOf() 메소드는 원시 타입을 받환하지 않고 단순히 객체 그 자신을 반환한다.**
    ```javascript
    var d = new Date(2010, 1, 1);   // 2010년 1월 1일
    d.valueOf()                     // => 1262332800000
    ```

## 변수 선언(3.9)
- 변수를 사용하기 전에 변수 선언을 해야 한다.
  ```javascript
  var i;
  var sum;
  var i, sum;
  var message = 'hello';
  ```
- var문에서 변수에 초기 값을 지정하지 않는다면, 변수는 값이 설정될 때까지 undefined 값을 갖게 된다.

## 변수의 유효범위
- 어떤 변수가 정의되어 있는 영역을 말한다.
- 전역 변수(global variable): 코드 전체에 걸쳐 정의되어 있는 변수
- 지역 변수(local variable): 어떤 함수 안에서 선언된 변수는 오직 해당 함수 몸체 안에서만 정의 된다.
  ```javascript
  var scope = 'global';         // 전역 변수를 선언한다.
  function checkscope() {
    var scope = 'local';        // 전역 변수와 같은 이름으로 지역 변수를 선언한다.
    return scope;               // 전역 변수가 아닌 지역 변수를 반환한다.
  }

  checkscope();                 // => 'local'

  ///////////////////////////////////////////////////////////////////////

  var scropt = 'glocal scope';          // 전역 변수

  function checkscope()  {
    var scope = 'local scope';          // 지역 변수
    function nested() {
      var scope = 'nested scope';       // 함수 안에 포함된 유혀범위의 지역 변수
      return scope;                     // nested() 안의 변수를 반환한다.
    }

    return nested();
  }

  checkscope();                         // => 'nested scope';
  ```

## 함수 유효범위와 끌어올림(hoising)
- 자바스트립트는 함수 유효밤위를 사용한다.
- 변수는 해당 변수가 정의된 함수 안에서 보일 뿐 아니라, 그 함수 안에 중첩된 함수 안에서도 보인다.
  ```javascript
  function test(o) {
    var i = 0;                            // i는 함수 전체에 걸쳐 정의 된다.
    if (type o == 'object') {
      var j = 0;                          // j는 블록뿐만 아니라 함수 전체에 걸쳐 정의된다.

      for(var k=0; k < 10; k++) {         // k는 반복문 외에도 함수 전체에 걸쳐 정의 된다.
          console.log(k);                 // 숫자 0부터 9까지 출력한다.
      }
      console.log(k);                     // => 10; k는 여전히 정의되어 있다.
    }
    console.log(j);                       // j는 정의되어 있고 조기회되어 있지 않을 것이다.
  }
  ```
- 함수 유효범위(funcion scope)는, 어떤 함수 안에서 선언된 모든 변수는 그 함수 전체에 걸쳐 유효하다.
- 자바스크립트 코드는 함수 안에 있는 모든 변수를 함수 맨 꼭대기로 '끌어올린' 것처럼 동작한다.
  ```javascript
  var scope = 'global';
  function f() {
    console.log(scope);     // 'global'이 아리나 'undefined'를 출력한다.
    var scope = 'local';    // 여기서 초기화하지만, 정의는 다른 곳에서 이루어 졌다.
    console.log(scope);     // 'local'을 출력한다.
  }
  ```
- 지역 변수는 함수 전체에 걸쳐서 정의된다. 즉 같은 이름의 젼역 변수는 함수 전체에서 이 지역 변수에 의해 감춰 진다.
- 변수를 선언하는 좋은 방법은, 가능한 한 그 변수가 사용되는 가장 가까운 곳에서 선언하는 것이다.

## 프로퍼티로서의 변수(3.10.2)
- 전역 자바스크립트 변수를 선언한다는 것은, 실제로는 전역 객체의 프로퍼티를 정의하는 것이다.
- 변수 선언을 **var** 를 사용하면
  - 생선된 프로퍼티는 수정 불가
  - **delete** 연산자로 소멸 시킬 수 없다는 뜻
- 엄격 모드가 아닌 상황에서 선언하지 않은 변수에 값을 대입하려고 하면 자바스크립트는 자동으로 전역 변수를 생성한다.
이런식으로 생성된 변수는 전역 객체의 평범하고 수정 가능한 프로퍼티이며 삭제 가능하다.

  ```javascript
  var truevar = 1;      // 올바르게 선언한 정력 변수, 삭제할 수 없다.
  fakevar = 2;          // 삭제 가능한 전역 변수
  this.fakevar2 = 3;    // 삭제 가능한 전역 변수
  delete truevar        // => false: 변수는 삭제할 수 없다.
  delete fakevar        // => true: 변수는 삭제된다.
  delete this.fakevar2  // => true: 변수는 삭제 된다.
  ```

## 유효범위 체인(3.10.3)
- 변수의 유효범위란 정의된 변수를 사용 가능한 소스코드의 집합으로 생각할 수 있다.
- 전역변수는 프로그램 전체에 결쳐 유효하다.
지역 변수는 변수가 선언된 함수 전체에 걸쳐 유효하고, 그 안에 중첩된 함수 내에서도 유효하다.
- 자바스크립트의 모든 코드 무더기는(전역 코드이건 함수이건) 그것과 연관된 유효범위 체인(scope chain)을 가지고 있다.
- 자바스크립트가 변수 x의 값을 얻어야 할 때 처음 체인에 있는 객체에서 x를 찾기 시작한다.
처음 객체에서 x인 프로퍼티를 가지고 있다면, 그대로 사용한다.
만약 첫 번째 객체가 x 프로퍼티를 가지고 있지 않다면 유효범위 체인에 있는 다음 객체에서 x 프로퍼티를 찾는다.
이렇게 순차적으로 유효범위 체인에서 x 프로퍼티를 찾게 되며 x가 유효범위 체인 안에 있는 객체의 프로퍼티가 아니라면 x는 유효범위 안에 없기 때문에 ReferenceError가 발생한다.
  ```javascript
  var a = 10;
  function outerFunction() {
    var b = 20;
    function innerFunction() {
      var c = 30;
      console.log('a=' + a + ', b=' + b + ', c=' + c);
    };
    return innerFunction();
  }
  outerFunction();
  // => a=10, b=20, c=30;
  ```
- 최상위 자바스크립트 코드의 경우(어떤 함수에 속하지 않는 코드), 유효범위 체인은 단 하나의 '전역 객체'만으로 이루어 진다.
