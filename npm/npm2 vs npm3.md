#npm v2와 npm v3의 차이



* 의존성 처리 방법이 변경 되었다.
* npm v2
    * npm 2에서는 각 모듈 하위에 의존성 모듈을 설치 한다.
    * npm 의존성 모듈은 node_modules 디렉토리 아래 설치 되는데 프로텍트가 a와 b모듈에 의존성(사용)을 가지고 있는데 각 모듈이 l, m모듈에 의존성을 가지고 있다면 다름과 같이 설치 된다.
<pre>
		node_modules/
		├── a/
		│   	└── node_modules/
		│       		└── l/
		└── b/
    			└── node_modules/
        					└── m/
</pre>
    * 예를 들어 a와 b가 같은 l 모듈를 사용 한다고 했을 때 버전이 다른 경우 다음과 같이 사용하는 버전이 각각 모듈의 하위 디텍터리에 설치 된다.
<pre>
		node_modules/
		├── a/
		│   	└── node_modules/
		│       		└── l/   # v1.0.0
		└── b/
    			└── node_modules/
        					└── l/  # v2.0.0
</pre>
    * 이 구조 덕분에 프로젝트에서 사용하는 모듈이 가진 의존성 간의 충돌은 신경 쓸 필요가 없다.
    * Node.js는 require()를 하는 경우 현재의 node_modules에서 먼저 찾고 없으면 부모 디렉터리로 가면서 계속 node_modules를 찾아서 의존성을 처리하기 때문에 우선순위상 자신의 디렉터리 하위에 있는 것을 먼저 사용하게 된다.
    * 이는 보통 의존성 관리에서 골치 아프게 발행하는 버전 충돌 문제를 잘 해결했지만 대신 비효율적인 부분과 약간의 문제를 발생시켰다.
    * 결론으로 npm v2는 버전이 다른 경우 각각 설치 되어서 괜찮다고 했지만 실제로는 같은 버전의 모듈을 사용한다고 하더라도 각각 설치 된다. 예를 들어 l@v1.0.0을 의존성을 가진 모듈이 10개 있다면 10번 설치가 된다. 큰 문제는 아니지만 불필요한 부분인 것은 확실하다.
* npm v3
    * 의존성 모듈을 계층적으로 설치하지 않고 가능한 한 계층을 없에서(flat) 설치 한다.
<pre>
		node_modules/
		├── a/
		├── b/
		├── l/
		└── m/
</pre>
    * 그러면 a와 b가 다른 버전의 모듈 l을 사용하는 경우에는 어떻게 될까? 즉, a는 l@v1.0.0을 사용하고 b는 l@2.0.0을 사용하는 경우에는 다음과 같이 설치 된다
<pre>
		node_modules/
		├── a/
		├── b/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		└── l/   # v1.0.0
</pre>
    * a가 먼저 설치 되면서 l@v1.0.0을 node_modules/ 아래에 설치하고 b를 설치 할 때 l@v2.0.0을 설치하려고 보니 루트에 이미 l@v1.0.0이 설치 되어 있으므로 b 하위에 설치 한다.
    * require(l)을 할 때의 동작 방식은 같으므로 a모듈에서 자신의 하위에 node_modules가 없으므로 상위 l(v1.0.0)을 사용하고 b는 하위에 l이 있으므로 v2.0.0을 사용해서 의존성이 충돌하는 문제가 발생하지 않는다.
    * 여기서 l@v2.0.0을 사용하는 모듈 c를 추가하면 b와 마찬가지고 이미 루트에 l 모듈이 있으므로 자신의 하위에 설치 해서 다음과 같이 된다.
<pre>
		node_modules/
		├── a/
		├── b/
		│   └── node_modules/
		│      	 	└── l/  # v2.0.0
		├── c/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		└── l/   # v1.0.0 
</pre>
    * 이 상황에서 l@v1.0.0을 사용하는 모듈 d를 설치하면 l@v1.0.0은 루트에 이미 설치 되어 있으므로 다음과 같이 된다.
<pre>
		node_modules/
		├── a/
		├── b/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── c/
		│   └── node_modules/
		│      		 └── l/  # v2.0.0
		├── d/
		└── l/   # v1.0.0 
</pre>
    * 여기서 a 모듈을 새 버전으로 업데이트 했는데 이제 l@v1.0.0 대신 l@v2.0.0을 사용한다면 루트에 이미 l@v1.0.0이 설치 되어 있고 d가 사용 중이므로 하위에 다시 설치해서 다음과 같이 된다.
<pre>
		node_modules/
		├── a/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── b/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── c/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── d/
		└── l/   # v1.0.0
</pre>
    * 여기서 d도 업데이트 했더니 l@v2.0.0을 사용한다면 이제 루트의 l@v1.0.0을 사용하는 모듈이 아무도 없으므로 l@v1.0.0을 지우고 l@v2.0.0을 루트에 설치 한다.
<pre>
		node_modules/
		├── a/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── b/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── c/
		│   └── node_modules/
		│       		└── l/  # v2.0.0
		├── d/
		└── l/   # v2.0.0
</pre>
    * 동작에는 문제가 없지만, 결과적으로 모든 모듈이 l@v2.0.0을 사용하고 있지만 중복되어 여러 곳에 설치가 되어 있다. 이때 npm dedupe
